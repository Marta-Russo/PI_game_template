<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>app/components/exp-lookit-games/base.js - ember-lookit-frameplayer</title>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="https://yui-s.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="https://yui-s.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">
<div id="doc">
    <div id="bd" class="yui3-g">
        <div class="yui3-u-1-5">
            <div id="docs-sidebar" class="sidebar apidocs">
              <h2 style="display:inline;">
              <div>
                <img style="float:right; vertical-align:middle;" src="../assets/css/logo.png" height="70">
                <span>Lookit<br> component<br> docs</span>
              </div>

              </h2>


              <div id="api-list">
                  <div id="api-tabview">
              
                    <div id="api-tabview-panel">
                        <h2 class="off-left">Collections</h2>
                        <ul id="api-modules" class="apis modules">
                            <li class="module-sidebar-components"><a href="../modules/components.html">components</a></li>
                            <li class="module-sidebar-exp-player"><a href="../modules/exp-player.html">exp-player</a></li>
                            <li class="module-sidebar-frames"><a href="../modules/frames.html">frames</a></li>
                            <li class="module-sidebar-games"><a href="../modules/games.html">games</a></li>
                            <li class="module-sidebar-mixins"><a href="../modules/mixins.html">mixins</a></li>
                            <li class="module-sidebar-randomizers"><a href="../modules/randomizers.html">randomizers</a></li>
                            <li class="module-sidebar-services"><a href="../modules/services.html">services</a></li>
                        </ul>
                        <h2 class="off-left">All elements</h2>
                              <div id="api-tabview-filter">
                      <input type="search" id="api-filter" placeholder="Type to filter">
                    </div>
                        <ul id="api-classes" class="apis classes">
                            <li><a href="../classes/Base.html">Base</a></li>
                            <li><a href="../classes/ButtonPressWindow.html">ButtonPressWindow</a></li>
                            <li><a href="../classes/DiscreteBounce.html">DiscreteBounce</a></li>
                            <li><a href="../classes/DiscreteButtonSpatial.html">DiscreteButtonSpatial</a></li>
                            <li><a href="../classes/DiscreteCatch.html">DiscreteCatch</a></li>
                            <li><a href="../classes/DiscreteCatchLift.html">DiscreteCatchLift</a></li>
                            <li><a href="../classes/Exp-exit-survey.html">Exp-exit-survey</a></li>
                            <li><a href="../classes/Exp-frame-base.html">Exp-frame-base</a></li>
                            <li><a href="../classes/Exp-frame-select.html">Exp-frame-select</a></li>
                            <li><a href="../classes/Exp-lookit-dialogue-page.html">Exp-lookit-dialogue-page</a></li>
                            <li><a href="../classes/Exp-lookit-exit-survey.html">Exp-lookit-exit-survey</a></li>
                            <li><a href="../classes/Exp-lookit-geometry-alternation.html">Exp-lookit-geometry-alternation</a></li>
                            <li><a href="../classes/Exp-lookit-geometry-alternation-open.html">Exp-lookit-geometry-alternation-open</a></li>
                            <li><a href="../classes/Exp-lookit-instructions.html">Exp-lookit-instructions</a></li>
                            <li><a href="../classes/Exp-lookit-mood-questionnaire.html">Exp-lookit-mood-questionnaire</a></li>
                            <li><a href="../classes/Exp-lookit-observation.html">Exp-lookit-observation</a></li>
                            <li><a href="../classes/Exp-lookit-preferential-looking.html">Exp-lookit-preferential-looking</a></li>
                            <li><a href="../classes/Exp-lookit-preview-explanation.html">Exp-lookit-preview-explanation</a></li>
                            <li><a href="../classes/Exp-lookit-story-page.html">Exp-lookit-story-page</a></li>
                            <li><a href="../classes/Exp-lookit-survey.html">Exp-lookit-survey</a></li>
                            <li><a href="../classes/Exp-lookit-text.html">Exp-lookit-text</a></li>
                            <li><a href="../classes/Exp-lookit-video.html">Exp-lookit-video</a></li>
                            <li><a href="../classes/Exp-lookit-video-assent.html">Exp-lookit-video-assent</a></li>
                            <li><a href="../classes/Exp-lookit-video-consent.html">Exp-lookit-video-consent</a></li>
                            <li><a href="../classes/Exp-player.html">Exp-player</a></li>
                            <li><a href="../classes/Exp-video-config.html">Exp-video-config</a></li>
                            <li><a href="../classes/Exp-video-config-quality.html">Exp-video-config-quality</a></li>
                            <li><a href="../classes/Exp-video-consent.html">Exp-video-consent</a></li>
                            <li><a href="../classes/Exp-video-preview.html">Exp-video-preview</a></li>
                            <li><a href="../classes/Expand-assets.html">Expand-assets</a></li>
                            <li><a href="../classes/ExpFrameGamesComponent.html">ExpFrameGamesComponent</a></li>
                            <li><a href="../classes/Full-screen.html">Full-screen</a></li>
                            <li><a href="../classes/Game.html">Game</a></li>
                            <li><a href="../classes/Media-reload.html">Media-reload</a></li>
                            <li><a href="../classes/Permute.html">Permute</a></li>
                            <li><a href="../classes/Random-parameter-set.html">Random-parameter-set</a></li>
                            <li><a href="../classes/Select.html">Select</a></li>
                            <li><a href="../classes/Session-record.html">Session-record</a></li>
                            <li><a href="../classes/Utils
              Shared Utility class for project static methods and constants.html">Utils
              Shared Utility class for project static methods and constants</a></li>
                            <li><a href="../classes/Video-record.html">Video-record</a></li>
                            <li><a href="../classes/video-recorder.html">video-recorder</a></li>
                        </ul>
                    </div>
              
                  </div>
              </div>
            </div>
        </div>
        <div class="yui3-u-4-5">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: app/components/exp-lookit-games/base.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
 * Developed by Gleb Iakovlev on 5/3/19 9:09 PM.
 * Last modified 4/29/19 10:46 PM.
 * Copyright (c) Cognoteq Software Solutions 2019.
 * All rights reserved
 */
import Utils from &#x27;./utils&#x27;;

/**
 *
 * @submodule games
 *
 */


const JITTER_MAX_TIME = 2000; // Max value for time Jitter randomizer
const JITTER_MIN_TIME = 850; // Min value for time Jitter randomizer
const DATA_COLLECTION_TIME = 20; // Data collection Timeout
let dataLoop = {}; // controlling data Collection loop
let gameLoop = {}; // controlling main game loop
let mouseY = 0; // mouse pointer  position on Y axis
let currentRounds = 0; // current game trial number
let maxRounds = 0;
let initBallY = 0.0; // Initial ball Y position
let initX = 0.52; // Initial ball X position
let initV = 0; //  Initial velocity
let gravity = 0;
let ballvx = 0;  // current ball velocity on X axis
let paddleBox = {
  position: {x: 0, y: 0},
  dimensions: {width: 0, height: 0}
};


// let INITIAL_SCREEN_WIDTH = this.canvas.width/1024; // X  screen from matlab
// let INITIAL_SCREEN_HEIGHT = this.canvas.height/768; // Y screen from matlab
const PADDLE_REST_TIME_MS = 3000;

/**
 * Base class for common game functions
 * TODO : some static methods could be extracted to a separate class, maybe Utils class
 * @class Base
 */
export default class Base {


  /**
   * Constructor to get parameters from caller
   * @method Constructor
   * @constructor Constructor
   * @param context from component
   * @param document object from component
   */
  constructor(context, document) {
    this.context = context;
    this.document = document;
    this.canvas = this.document.getElementById(&#x27;gamesCanvas&#x27;);
    this.ctx = this.canvas.getContext(&#x27;2d&#x27;);
    this.currentScore = 0;
    this.canvas.style.cursor = &#x27;none&#x27;;
    // Event listener for mouse and keyboard here
    document.addEventListener(&#x27;keydown&#x27;, this.keyDownHandler, false);
    document.addEventListener(&#x27;keyup&#x27;, this.keyUpHandler, false);
    // this.canvas.requestPointerLock =  this.canvas.requestPointerLock || this.canvas.mozRequestPointerLock || this.canvas.webkitRequestPointerLock;
    // this.canvas.requestPointerLock()
    this.calculateCanvas();
    this.paddleBoxParameters();

    this.loopTimer = function () {
      let inst = this;
      gameLoop = window.requestAnimationFrame(function () {
        inst.loop();
      });

    };


    this.dataTimer = function () {
      let inst = this;
      dataLoop = setTimeout(function () {
        inst.dataCollection();
      }, DATA_COLLECTION_TIME);

    };

  }


  paddleBoxParameters() {
    let leftBorder = (1.2035) * Utils.SCALE;
    let topBorder = (1.3671) * Utils.SCALE;
    let rightBorder = (1.4585) * Utils.SCALE;
    let downBorder = (1.5671) * Utils.SCALE;
    paddleBox.position.x = leftBorder;
    paddleBox.position.y = topBorder;
    paddleBox.dimensions.width = rightBorder - leftBorder;
    paddleBox.dimensions.height = downBorder - topBorder;
  }

  /**
   * Calculate canvas based on current Width Height
   * of the screen and initial Aspect ratio.
   * Currently using Matlab implementation Aspect ratio (4:3)
   * @method calculateCanvas
   */
  calculateCanvas(){

    //  this.canvas.height =  screen.height ;
    //  this.canvas.width = screen.width;
    //  let ratio = this.canvas.height/this.canvas.width;
    //  let height = this.Utils.SCREEN_HEIGHT;
    //  if(ratio &gt;= 0.6 &amp;&amp; ratio &lt; 0.7 ){
    //    height = 800;
    //  }else if(ratio &gt;= 0.7){
    //    height = 900;
    //  }
    //
    // this.Utils.SCALE  =  this.context.scale_factor * (this.canvas.height/height);

    this.canvas.height = 768 ;
    this.canvas.width =  1024;
    this.Utils.SCALE  =  420;

    // if(screen.height &lt; screen.width) {
    //   this.canvas.height = screen.height;
    //   let coefficient = screen.height/768;
    //   this.canvas.width = coefficient * 1024;
    //   this.Utils.SCALE  =  420 * coefficient;
    // }else{
    //   this.canvas.width = screen.width;
    //   let coefficient = screen.width/768;
    //   this.canvas.height = coefficient * 768;
    //   this.Utils.SCALE  =  420 * coefficient;
    // }


  }


  /**
   * Initialize or start the game loop here
   * @method init
   */
  init() {
    this.currentScore = 0;
    this.currentRounds = 0;
    clearInterval(dataLoop);
    this.dataTimer();
  }

  generateHeights() {

    return this.uniformArr([1,2,3]);
  }


  /**
   * Generate main trajectory parameters per trial
   * @method generateTrajectoryParams
   * @param hArr array of equally distributed height
   * @param height height correction coefficient
   * @param Tf Flight time coefficient
   */
  generateTrajectoryParams(hArr, height, Tf) {
    let currentHeight = hArr[currentRounds] * 0.05 + height;
    initX = 0.52;
    let val = hArr[currentRounds] - 1;
    Tf = Tf + val * 0.144;
    gravity = 2 * currentHeight / Math.pow(Tf, 2);
    ballvx = (1.051) / Tf;
    initV = 0.5 * gravity * Tf;

  }


  /**
   * Generate Trajectory  parameters for discrete games (using Time Flight array)
   * @method generateTrajectoryParamsDiscrete
   * @param TfArr Time Flight array
   */
  generateTrajectoryParamsDiscrete(TfArr) {
    let Tf = TfArr[currentRounds];
    let height = 0.8;
    initX = 0.7510;
    gravity = 2 * height / Math.pow(Tf, 2);
    ballvx = (1.051) / Tf;
    initV = 0.5 * gravity * Tf;
  }


  /**
   * Generate Trajectory  parameters for spatial discrete games  (using init velocity matrix )
   * @method generateTrajectoryParamsDiscreteSpatial
   * @param initVmatrix  init velocity matrix
   */
  generateTrajectoryParamsDiscreteSpatial(initVmatrix) {
    let Tf = 0.9;
    gravity = 1.8;
    ballvx = (1.051) / Tf;
    initV = 0.15 * initVmatrix[currentRounds] + 0.45;
    initX = 0.7510;
    initBallY = -0.02;
  }


  /**
   * Create and draw box for initial paddle location.
   * The box symbolizes initial paddle location in all games
   * @param color {int} Color of the Paddle box
   * @param fill {boolean} Set solid color paddle box
   * @method createPaddleBox
   */
  createPaddleBox(color = Utils.blueColor, fill = false) {

    if(fill){

      this.ctx.fillStyle = color;
      this.ctx.fillRect(paddleBox.position.x, paddleBox.position.y, paddleBox.dimensions.width, paddleBox.dimensions.height);

    }else{

      this.ctx.beginPath();
      this.ctx.rect(paddleBox.position.x, paddleBox.position.y, paddleBox.dimensions.width, paddleBox.dimensions.height);
      this.ctx.fillStyle = color;
      this.ctx.lineWidth = &#x27;8&#x27;;
      this.ctx.strokeStyle = color;
      this.ctx.stroke();
    }



  }



  /**
   * Create Uniform array of values
   * @method uniformArr
   * @param vals {array} Array of values that  needed to be equally distributed
   * @return {array} array
   */
  uniformArr(vals) {
    let arr = [];
    vals.forEach((v) =&gt; {
      arr = arr.concat(Array(maxRounds / vals.length).fill(v));

    });

    return Utils.shuffle(arr);

  }



  stop() {

    clearInterval(dataLoop);

  }

  /**
   * Abstract method
   * Triggered when participant pressed some key on keyboard
   * @method keyDownHandler
   * @param {object} e event
   */
  keyDownHandler(e) {

    console.log(e);
  }

  /**
   * Abstract method
   * Triggered when participant released some key on keyboard
   * @method keyUpHandler
   * @param {object} e event
   */
  keyUpHandler(e) {

    console.log(e);
  }


  /**
   * Data collection abstract method
   * Executing method only once in DATA_COLLECTION_TIME timeout
   * @method dataCollection
   */
  dataCollection() {


    this.dataTimer();

  }

  /**
   * Current score accumulator
   * @method increaseScore
   */
  increaseScore() {
    this.currentScore++;
  }



  /**
   * Abstract Main game loop method
   * @method loop
   */
  loop() {

    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.fillStyle = Utils.blackColor;
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.save();

    //this.drawScore();

    this.loopTimer();
  }


  /**
   * Create initial ball box object to start from
   * @method createLauncher
   * @param {object} Image object
   */
  createLauncher(image) {

    let leftBorder = 0.4 * Utils.SCALE;
    let topBorder = 1.2971 * Utils.SCALE;
    let rightBorder = (0.64) * Utils.SCALE;
    let downBorder = 1.5671 * Utils.SCALE;

    this.ctx.drawImage(image, leftBorder, topBorder, rightBorder - leftBorder, downBorder - topBorder);

  }


  get currentRounds() {

    return currentRounds;
  }

  set currentRounds(val) {

    currentRounds = val;
  }

  /**
   * Set maximum number of trials per game
   * @method setMaxTrials
   * @param {int} trials
   */
  setMaxTrials(trials){

    maxRounds = trials;

  }


  /**
   * Get shared Utils objects
   * @method Utils
   * @return {Utils}
   * @constructor
   */
  get Utils() {

    return Utils;
  }


  /**
   * Get trajectory parameters per each trial
   * @method TrajectoryVars
   * @return {object} {{initX: number, ballvx: number, gravity: number, initV: number}}
   * @constructor
   */
  get TrajectoryVars() {

    return {initX: initX, gravity: gravity, ballvx: ballvx, initV: initV};
  }


  /**
   * Show current image
   * @method drawImage
   * @param {object} object  Current object with x,y position, width , height and URL of the image to show
   * @param {object} image Image object
   */
  drawImage(object, image) {
    this.ctx.fillStyle = Utils.blackColor;
    this.ctx.fillRect(object.position.x, object.position.y, object.dimensions.width, object.dimensions.height);
    this.ctx.drawImage(image, object.position.x, object.position.y, object.dimensions.width, object.dimensions.height);
  }


  /**
   * Fill image array with objects according to URL sources
   * @method fillImageArray
   * @param {array} array of URLs
   * @param {array} array of created objects
   */
  fillImageArray(urlArr,imgArr){

    urlArr.forEach(
      url =&gt;{
        let img = new Image();
        img.src = url;
        imgArr.push(img);
      }

    );

  }

  /**
   * Fill audio array with objects according to URL sources
   * @method fillAudioArray
   * @param {array} array of URLs
   * @param {array} array of created objects
   */
  fillAudioArray(urlArr,audioArr){

    urlArr.forEach(
      url =&gt;{
        let audio = new Audio();
        audio.src = url;
        audio.load();
        audioArr.push(audio);
      }

    );

  }

  /**
   * Store data and pass to  Lookit platform variable
   * @method storeData
   * @param {array} export Data array of objects with all data passed to Lookit platform
   */
  storeData(exportData) {

    this.context.get(&#x27;export_arr&#x27;).addObject(exportData);

  }


  /**
   * Initialize current round of the game
   * @method initGame
   */
  initGame() {

    this.loopTimer();

  }


  /**
   * Finish current round and check for rounds left
   * @method finishGame
   * @param score {boolean} should increase score
   */
  finishGame(score) {

    this.currentRounds++;
    this.clearInterval();
    cancelAnimationFrame(gameLoop);
    if (score) {
      this.increaseScore();
    }
    if (this.currentRounds &lt; maxRounds) {
      this.initGame();

    } else {
      this.context.set(&#x27;showInstructions&#x27;, true);
      this.context.stopRecorder().finally(() =&gt; {
        this.context.destroyRecorder();
        this.context.send(&#x27;export&#x27;);
        this.context.send(&#x27;next&#x27;);
      });
    }

  }

  /**
   * Clear all current running game loops
   * @method clearInterval
   */
  clearInterval() {

    window.clearInterval(0);

  }




  /**
   * Basket object per Matlab coordinates
   * @method basketObject
   * @param basket paddle parameters
   * @return {object} basket parameters
   */
  basketObject(basket) {

    let position = (this.canvas.height - mouseY)/this.canvas.height ;
    let radiusRim = 0.1;
    let leftBorder = (1.3310 - radiusRim) * Utils.SCALE;
    let topBorder = (1.3671 - position) * Utils.SCALE;
    let rightBorder = (1.3310 + radiusRim) * Utils.SCALE;
    let downBorder = (1.5371 - position) * Utils.SCALE;

    basket.position = {x: leftBorder, y: mouseY};
    basket.dimensions = {width: rightBorder - leftBorder, height: downBorder - topBorder};


    return basket;

  }


  /**
   * Store paddle position and time history for velocity calculation
   * @method paddleHistory
   * @param {object} paddle
   * @param {int} trial initial Time in Unixtime
   */
  paddleHistory(paddle, initialTime) {


    paddle.times.push(this.getElapsedTime(initialTime));
    if(paddle.positions.length &gt; 80){
      paddle.positions = paddle.positions.slice(-80);
    }
    paddle.positions.push((this.canvas.height - paddle.position.y) / this.canvas.height);

  }

  /**
   * Paddle object per Matlab coordinates
   * @method paddleObject
   * @param {object} paddle
   * @return {object} paddle {position: {x: number, y: number}, dimensions: {width: number, height: number}}
   */
  paddleObject(paddle){
    let position = (this.canvas.height - mouseY)/this.canvas.height ;
    let leftBorder = (1.256)*Utils.SCALE ;
    let topBorder = (1.3671-position)*Utils.SCALE;
    let rightBorder = (1.406)*Utils.SCALE;
    let downBorder =  (1.3871-position)*Utils.SCALE ;

    paddle.position = {x: leftBorder,y:mouseY};
    paddle.dimensions = {width: rightBorder - leftBorder, height: downBorder-topBorder};

    return paddle;

  }

  /**
   * Create initial ball object with state parameters for all games
   * Initial state is always &#x27;start&#x27; for each game trial
   * @method ballObject
   * @return {object} ball  {{color: string, impactPosition: number, startTime: number, positions: {x: number, y:
   * number}[],
   * position: {x: number, y: number}, velocity: number, state: string, hitstate: string, radius: number, impactTime: number}}
   */
  ballObject(){

    let iterator = 0.001;
    let positionY = initBallY+initV*(iterator)+0.5*-gravity*Math.pow(iterator,2);
    let positionX  = initX + ballvx*(iterator);
    let leftBorder =  (positionX- 0.0175) * Utils.SCALE;
    let downBorder =  (1.3746-positionY) * Utils.SCALE ;

    return {

      position: {x: leftBorder, y: downBorder},
      velocity: 0,
      radius: (0.037) * Utils.SCALE,
      state: &#x27;start&#x27;,
      impactTime: 0,
      hitstate: &#x27;&#x27;,
      startTime: 0,
      impactPosition: 0,
      positions: [{x: 0, y: 0}],
      color: Utils.yellowColor

    };
  }

  /**
   * Get elapsed time as iterator in seconds
   * @method getElapsedTime
   * @param intialTime {int} Unixtime formatted time
   * @return {number}  difference in seconds between current time and intialTime, decimal
   */
  getElapsedTime(intialTime) {

    return (new Date().getTime() - intialTime) / 1000;
  }

  /**
   * Projectile motion trajectory per maximum distance
   * @method trajectory
   * @param ball {Object} {position: {x: number, y: number}, radius: number, dimensions: {width: number, height:
   * number}}
   * @param initialTime {int}
   */
  trajectory(ball, initialTime) {

    let  iterator =  this.getElapsedTime(initialTime);
    this.ctx.beginPath();

    let positionY = initBallY+initV*(iterator)+0.5*-gravity*Math.pow(iterator,2);
    let positionX  = initX + ballvx*(iterator);
    let leftBorder =  (positionX- 0.0175)* Utils.SCALE;
    let downBorder =  (1.3746-positionY)*Utils.SCALE ;
    ball.position.x = leftBorder;
    ball.position.y = downBorder;

  }

  /**
   * Draw the game score
   * @method drawScore
   */
  drawScore() {
    this.ctx.font = &#x27;16px Arial&#x27;;
    this.ctx.fillStyle = Utils.scoreColor;
    this.ctx.fillText(&#x27;Score: &#x27; + this.currentScore, 8, 20);
  }



  /**
   * Randomize trial start time
   * @method trialStartTime
   * @return {number} seconds
   */
  trialStartTime() {

    return ((Math.floor(Math.random() * (JITTER_MAX_TIME - JITTER_MIN_TIME + 1)) + JITTER_MIN_TIME) / 1000 );

  }

  /**
   * Check if ball is on the floor and missed target
   * @method ballIsOnFloor
   * @param ball {position: {x: number, y: number}, radius: number, dimensions: {width: number, height:
   * number}}
   * @return {boolean}
   */
  ballIsOnFloor(ball){

    return ball.position.y &gt; paddleBox.position.y + paddleBox.dimensions.height - 0.048 * Utils.SCALE;
  }

  /**
   * Draw ball per x,y ball location
   * @method drawBall
   * @param ball {Object} {position: {x: number, y: number}, radius: number, dimensions: {width: number, height:
   * number}}
   */
  drawBall(ball,image) {

    this.ctx.drawImage(image, ball.position.x, ball.position.y, ball.radius, ball.radius);

  }


  /**
   * Set position of the ball to initial coordinates to symbolize the start of the game
   * @method moveBallToStart
   * @param {object} ball {position: {x: number, y: number}, radius: number, dimensions: {width: number, height: number}} object parameters set game to be over
   * @param {object} Image object
   */
  moveBallToStart(ball,image) {

    ball = this.ballObject();
    this.drawBall(ball,image);

  }

  /**
   * Check if user returned paddle to initial coordinates and call finish of the game to restart
   * current round
   * Check if paddle is stationary for PADDLE_REST_TIME_MS, if yes proceed to the next trial
   * @method paddleAtZero
   * @param {object} paddle {position: {x: number, y: number}, dimensions: {width: number, height: number}}
   * @param {boolean} score should increase score
   */
  paddleAtZero(paddle, score) {


    let topBorder = 1.3671 * Utils.SCALE;

    if (paddle.position.y &gt;= topBorder) {
      // Check if paddle is not moving inside the box
      let paddleTimeArrSize = paddle.positions.length;
      if (paddle.paddleLastMovedMillis === 0 || (paddle.position.y !== (this.canvas.height - paddle.positions[paddleTimeArrSize - 1] * this.canvas.height))) {
        paddle.paddleLastMovedMillis = new Date().getTime();

      } else if (new Date().getTime() - paddle.paddleLastMovedMillis &gt;= PADDLE_REST_TIME_MS) {
        paddle.paddleLastMovedMillis = 0;
        this.finishGame(score);
      }

    } else {

      paddle.paddleLastMovedMillis = 0;
    }

  }

  /**
   * Check if paddle is moved ahead of time
   * @method paddleIsMoved
   * @param {object} paddle parameters object {position: {x: number, y: number}, dimensions: {width: number, height: number}}
   * @param {boolean} checkPaddleHeight if height needed for reference (bounce game)
   * @return {boolean}
   */
  paddleIsMoved(paddle,checkPaddleHeight = false){

    if( paddle.positions.length &gt; 2 &amp;&amp; paddle.position.y !== (this.canvas.height - paddle.positions[paddle.positions.length-3]*this.canvas.height)){

      return true;
    }

    let paddleHeight = 0;
    if(checkPaddleHeight){
      paddleHeight = paddle.dimensions.height;
    }

    // Check if paddle is moved outside the box limits
    return paddle.position.y &lt; paddleBox.position.y - paddleBox.dimensions.height + paddleHeight;

  }



  /**
   * Draw image object according to object parameters
   * @method  drawImageObject
   * @param {object} {position: {x: number, y: number}, dimensions: {width: number, height: number}}
   * @param {object} image
   */
  drawImageObject(object,image){

    this.ctx.drawImage(image, object.position.x, object.position.y, object.dimensions.width, object.dimensions.height);

  }


  /**
   * Set paddle coordinates up to velocity
   * Check if paddle not going past the paddle box bottom border
   * Move paddle inside paddle Box upon start of the game
   * @method paddleMove
   * @param {object} paddle {position: {x: number, y: number}, dimensions: {width: number, height: number}}
   * @param {int} initialTime,  Initial time (Unixtime) for current game round
   * @param {object} ball {position: {x: number, y: number}, radius: number, dimensions: {width: number, height: number}}
   */
  paddleMove(paddle,initialTime,ball) {


    //Do not go over the bottom border
    if(paddle.position.y &gt; paddleBox.position.y + paddleBox.dimensions.height - paddle.dimensions.height){

      paddle.position.y = paddleBox.position.y + paddleBox.dimensions.height - paddle.dimensions.height;
    }

    // Move paddle inside paddle Box upon start of the game
    if(ball.state === &#x27;start&#x27; &amp;&amp; currentRounds === 0 &amp;&amp; paddle.position.y &lt; paddleBox.position.y) {

      mouseY = paddle.position.y + 0.0238 * Utils.SCALE;
    }

    this.paddleHistory(paddle,initialTime);


  }


  /**
   * Walls and target collisions detection
   * @method wallCollision
   * @param {object} ball
   * @return {boolean} if hit any edge of the screen
   */
  wallCollision(ball) {

    if (ball.position.y &gt; this.canvas.height + ball.radius || ball.position.x &gt; this.canvas.width + ball.radius || ball.position.x &lt; ball.radius) {

      return true;

    }

    return false;

  }

  /**
   * Increment current position cursor by movementY value (difference in y coordinate between the given event and the
   * previous mousemove event )
   * Check initial cursor position, if the positio is lower then low paddle box border, stop t\
   * mouse pointer updates.
   * @method onMouseMove
   * @param e {Event} currrent mouse event
   */
  onMouseMove(e){


    let border = paddleBox.position.y+paddleBox.dimensions.height/2;

    mouseY += e.movementY;

    if(e.movementY === 0){
      mouseY -= 1;
    }

    if(mouseY  &gt; border &amp;&amp; e.movementY &gt;0){
      mouseY =  border;
    }


  }




}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
