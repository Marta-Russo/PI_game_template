<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>app/components/exp-lookit-games/discreteBounce.js - ember-lookit-frameplayer</title>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="https://yui-s.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="https://yui-s.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">
<div id="doc">
    <div id="bd" class="yui3-g">
        <div class="yui3-u-1-5">
            <div id="docs-sidebar" class="sidebar apidocs">
              <h2 style="display:inline;">
              <div>
                <img style="float:right; vertical-align:middle;" src="../assets/css/logo.png" height="70">
                <span>Lookit<br> component<br> docs</span>
              </div>

              </h2>


              <div id="api-list">
                  <div id="api-tabview">
              
                    <div id="api-tabview-panel">
                        <h2 class="off-left">Collections</h2>
                        <ul id="api-modules" class="apis modules">
                            <li class="module-sidebar-components"><a href="../modules/components.html">components</a></li>
                            <li class="module-sidebar-exp-player"><a href="../modules/exp-player.html">exp-player</a></li>
                            <li class="module-sidebar-frames"><a href="../modules/frames.html">frames</a></li>
                            <li class="module-sidebar-games"><a href="../modules/games.html">games</a></li>
                            <li class="module-sidebar-mixins"><a href="../modules/mixins.html">mixins</a></li>
                            <li class="module-sidebar-randomizers"><a href="../modules/randomizers.html">randomizers</a></li>
                            <li class="module-sidebar-services"><a href="../modules/services.html">services</a></li>
                        </ul>
                        <h2 class="off-left">All elements</h2>
                              <div id="api-tabview-filter">
                      <input type="search" id="api-filter" placeholder="Type to filter">
                    </div>
                        <ul id="api-classes" class="apis classes">
                            <li><a href="../classes/Base.html">Base</a></li>
                            <li><a href="../classes/ButtonPressWindow.html">ButtonPressWindow</a></li>
                            <li><a href="../classes/DiscreteBounce.html">DiscreteBounce</a></li>
                            <li><a href="../classes/DiscreteButtonSpatial.html">DiscreteButtonSpatial</a></li>
                            <li><a href="../classes/DiscreteCatch.html">DiscreteCatch</a></li>
                            <li><a href="../classes/DiscreteCatchLift.html">DiscreteCatchLift</a></li>
                            <li><a href="../classes/Exp-exit-survey.html">Exp-exit-survey</a></li>
                            <li><a href="../classes/Exp-frame-base.html">Exp-frame-base</a></li>
                            <li><a href="../classes/Exp-frame-select.html">Exp-frame-select</a></li>
                            <li><a href="../classes/Exp-lookit-dialogue-page.html">Exp-lookit-dialogue-page</a></li>
                            <li><a href="../classes/Exp-lookit-exit-survey.html">Exp-lookit-exit-survey</a></li>
                            <li><a href="../classes/Exp-lookit-geometry-alternation.html">Exp-lookit-geometry-alternation</a></li>
                            <li><a href="../classes/Exp-lookit-geometry-alternation-open.html">Exp-lookit-geometry-alternation-open</a></li>
                            <li><a href="../classes/Exp-lookit-instructions.html">Exp-lookit-instructions</a></li>
                            <li><a href="../classes/Exp-lookit-mood-questionnaire.html">Exp-lookit-mood-questionnaire</a></li>
                            <li><a href="../classes/Exp-lookit-observation.html">Exp-lookit-observation</a></li>
                            <li><a href="../classes/Exp-lookit-preferential-looking.html">Exp-lookit-preferential-looking</a></li>
                            <li><a href="../classes/Exp-lookit-preview-explanation.html">Exp-lookit-preview-explanation</a></li>
                            <li><a href="../classes/Exp-lookit-story-page.html">Exp-lookit-story-page</a></li>
                            <li><a href="../classes/Exp-lookit-survey.html">Exp-lookit-survey</a></li>
                            <li><a href="../classes/Exp-lookit-text.html">Exp-lookit-text</a></li>
                            <li><a href="../classes/Exp-lookit-video.html">Exp-lookit-video</a></li>
                            <li><a href="../classes/Exp-lookit-video-assent.html">Exp-lookit-video-assent</a></li>
                            <li><a href="../classes/Exp-lookit-video-consent.html">Exp-lookit-video-consent</a></li>
                            <li><a href="../classes/Exp-player.html">Exp-player</a></li>
                            <li><a href="../classes/Exp-video-config.html">Exp-video-config</a></li>
                            <li><a href="../classes/Exp-video-config-quality.html">Exp-video-config-quality</a></li>
                            <li><a href="../classes/Exp-video-consent.html">Exp-video-consent</a></li>
                            <li><a href="../classes/Exp-video-preview.html">Exp-video-preview</a></li>
                            <li><a href="../classes/Expand-assets.html">Expand-assets</a></li>
                            <li><a href="../classes/ExpFrameGamesComponent.html">ExpFrameGamesComponent</a></li>
                            <li><a href="../classes/Full-screen.html">Full-screen</a></li>
                            <li><a href="../classes/Game.html">Game</a></li>
                            <li><a href="../classes/Media-reload.html">Media-reload</a></li>
                            <li><a href="../classes/Permute.html">Permute</a></li>
                            <li><a href="../classes/Random-parameter-set.html">Random-parameter-set</a></li>
                            <li><a href="../classes/Select.html">Select</a></li>
                            <li><a href="../classes/Session-record.html">Session-record</a></li>
                            <li><a href="../classes/Utils
              Shared Utility class for project static methods and constants.html">Utils
              Shared Utility class for project static methods and constants</a></li>
                            <li><a href="../classes/Video-record.html">Video-record</a></li>
                            <li><a href="../classes/video-recorder.html">video-recorder</a></li>
                        </ul>
                    </div>
              
                  </div>
              </div>
            </div>
        </div>
        <div class="yui3-u-4-5">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: app/components/exp-lookit-games/discreteBounce.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
 * Developed by Gleb Iakovlev on 5/3/19 9:09 PM.
 * Last modified 4/27/19 3:26 PM.
 * Copyright (c) Cognoteq Software Solutions 2019.
 * All rights reserved
 */
import Base from &#x27;./base&#x27;;

/**
 *
 * @submodule games
 *
 */

let paddle = {}; // Paddle parameters object
let ball = {}; // Ball parameters object
let target = {}; // Target parameters object
let initialTime = 0; // Initial time for current game trial
let alpha = 0.7; // Restitute factor
let hArray = []; // Actual height parameters are calculated from the Initial height by multiplying the  uniformly randomized  values in  vector
let targetLocH = 1.66;
let targetLocV = 0.69;
let jitterT = 0; // Time jitter (variates from 500 ms to 1500 ms), time between sound start and ball starting to fly
let Tf = 0.75; // Time Flight for trajectory
let Height = 0.65; // Current trajectory height
let token = {}; // Token parameters object
let tokenReached = {}; // Token parameters object when target is reached
let bricks = {}; // Bricks positions parameters object

// Media arrays for loading
let sounds = [];
let soundURLs = [];
let imageURLs = [];
let images = [];

// Media mapping as Enum
const gameSound = {
  START: 0,
  BOUNCING: 1,
  CATCH_GREAT: 2,
  CATCH_GOOD: 3,
  FAIL:4
};

const gameImage = {
  PADDLE: 0,
  WALL_INITIAL: 1,
  WALL_MISSED: 2,
  BALL: 3,
  BALLBOX: 4,
  BRICKS_SMALL: 5,
  BRICKS_LARGE: 6,
  TOKEN: 7
};





/**
 * Main implementation of Bounce  game.
 * The user will operate with paddle to bounce the ball into the object target.
 * The trajectory is randomized with various values in trajectories array
 * @class DiscreteBounce
 * @extends Base
 *
 */
export default class DiscreteBounce extends Base {


  /**
   * Constructor to get parameters from caller
   * @method constructor
   * @constructor constructor
   * @param context from component
   * @param document object from component
   */
  constructor(context, document) {

    super(context, document);
    soundURLs = [super.Utils.drumRollSound, super.Utils.bouncingSound, super.Utils.brickHitlarge, super.Utils.brickHitsmall, super.Utils.ballcatchFailSound];
    imageURLs = [this.Utils.paddleImage, super.Utils.wallInitial, super.Utils.wallMissed, super.Utils.basketBall, super.Utils.basketBalls, super.Utils.smallbricksImage, super.Utils.largebricksImage, super.Utils.tokenImage];

  }

  /**
   * Main point to start the game.
   * Initialize static parameters and preload sounds here
   * @method init
   */
  init() {

    document.addEventListener(&quot;mousemove&quot;, super.onMouseMove);
    paddle = {

      position: {x: 0, y: 0},
      dimensions: {width: 0, height: 0},
      paddleLastMovedMillis: 100,
      releaseVelocity: 1,
      positions: [],
      times: [],

    };
    hArray = super.generateHeights();


    let leftBorder = (1.48) * super.Utils.SCALE;
    let downBorder = (0.43) * super.Utils.SCALE;

    target = {

      dimensions: {width: 0.5 * super.Utils.SCALE, height: 0.5 * super.Utils.SCALE},
      position: {x: leftBorder, y: downBorder}
    };


    bricks = {

      dimensions: {width: 0.2 * super.Utils.SCALE, height: 0.2 * super.Utils.SCALE},
      position: {x: 1.7 * super.Utils.SCALE, y: 1.367 * super.Utils.SCALE}

    };


    token = {

      dimensions: {width: 0.21 * super.Utils.SCALE, height: 0.2 * super.Utils.SCALE},
      position: {x: 1.85 * super.Utils.SCALE, y: 0.34 * super.Utils.SCALE}

    };

    tokenReached = {

      dimensions: {width: token.dimensions.width * 2, height: token.dimensions.height * 2},
      position: {
        x: token.position.x - token.dimensions.width / 2,
        y: token.position.y - token.dimensions.height / 2
      }
    };

    super.fillAudioArray(soundURLs,sounds);
    super.fillImageArray(imageURLs,images);

    sounds[gameSound.START].addEventListener(&#x27;canplaythrough&#x27;, this.initGame(), false);
    sounds[gameSound.START].addEventListener(&#x27;playing&#x27;, function () {
      initialTime = new Date().getTime();
    });
    super.init();
  }


  /**
   *
   * Main loop of the game.
   * Set initial position of the ball in a box and starting  sound .
   * After that  start ball trajectory.
   * If ball hits the target or missed the target (hits any screen edge) wait util user places the paddle to starting position and move
   * the ball to initial position.
   * Increase the score if ball hits the target.
   * Currently game has 2 states when ball hits the target : good (hits the target within the window), very good
   * (hits exact target)
   * @method loop
   */
  loop() {
    super.loop();
    paddle = super.paddleObject(paddle);
    let paddleBoxColor = super.Utils.blueColor;
    super.createPaddleBox(paddleBoxColor);
    super.generateTrajectoryParams(hArray, Height, Tf);
    super.createLauncher(images[gameImage.BALLBOX]);
    super.drawImageObject(paddle, images[gameImage.PADDLE]);
    super.paddleMove(paddle, initialTime, ball);
    this.paddleBallCollision();
    super.drawImageObject(token, images[gameImage.TOKEN]);
    let hitTheTarget = this.collisionDetection();
    let hitTheWall = super.wallCollision(ball);

    if (initialTime === 0 &amp;&amp; super.currentRounds === 0 &amp;&amp; !super.paddleIsMoved(paddle,true)) {

      sounds[gameSound.START].play();
    }

    if (ball.state === &#x27;start&#x27;) {
      super.moveBallToStart(ball, images[gameImage.BALL]);
      if (initialTime &gt; 0 &amp;&amp; super.paddleIsMoved(paddle,true)) {
        initialTime = new Date().getTime();
        paddleBoxColor = super.Utils.redColor;
        super.createPaddleBox(paddleBoxColor);
      }

      if (initialTime &gt; 0 &amp;&amp; super.getElapsedTime(initialTime) &gt; jitterT) {
        sounds[gameSound.START].pause();
        sounds[gameSound.START].currentTime = 0;
        ball.state = &#x27;fall&#x27;;
        initialTime = new Date().getTime();
      }

    }


    if (ball.state === &#x27;fall&#x27;) {
      if (initialTime &gt; 0 &amp;&amp; super.getElapsedTime(initialTime) &lt; 0.95) {
        super.trajectory(ball, initialTime);
      }

      if (initialTime &gt; 0 &amp;&amp; super.ballIsOnFloor(ball)) {
        ball.state = &#x27;hit&#x27;;
      }
      super.drawBall(ball, images[gameImage.BALL]);
    }

    if (ball.state === &#x27;bounce&#x27;) {
      this.bounceTrajectory();
      super.drawBall(ball, images[gameImage.BALL]);

    }


    if ((hitTheTarget || hitTheWall) &amp;&amp; ball.state !== &#x27;done&#x27;) {

      ball.state = &#x27;hit&#x27;;
    }


    if (ball.state === &#x27;hit&#x27;) {
      // Remove ball and show in the starting point,
      //User should set the paddle to initial position , call stop after that
      super.drawImageObject(token, images[gameImage.TOKEN]);
      if (ball.hitstate === &#x27;very good&#x27;) {
        sounds[gameSound.CATCH_GREAT].play();
        super.increaseScore();

      } else if (ball.hitstate === &#x27;good&#x27;) {
        sounds[gameSound.CATCH_GOOD].play();
        super.increaseScore();

      } else {
        sounds[gameSound.FAIL].play();
      }


      ball.state = &#x27;done&#x27;;

    }


    if (ball.state === &#x27;done&#x27;) {

      if (ball.hitstate === &#x27;very good&#x27;) {
        super.drawImageObject(bricks, images[gameImage.BRICKS_LARGE]);
        super.drawImageObject(tokenReached, images[gameImage.TOKEN]);
      } else if (ball.hitstate === &#x27;good&#x27;) {
        super.drawImageObject(target, images[gameImage.WALL_MISSED]);
        super.drawImageObject(bricks, images[gameImage.BRICKS_SMALL]);
      } else {
        super.drawImageObject(target, images[gameImage.WALL_INITIAL]);
        super.drawBall(ball, images[gameImage.BALL]);
      }

      super.paddleAtZero(paddle, false);


    }

    if (ball.state !== &#x27;done&#x27;) {

      super.drawImageObject(target, images[gameImage.WALL_INITIAL]);
    }

    super.paddleMove(paddle, initialTime, ball);


  }


  getArraysum(a) {

    return a.reduce((t, n) =&gt; t + n);

  }

  getArrayMean(a) {

    return this.getArraysum(a) / a.length;

  }

  subtractFromEachElement(a, val) {

    return a.map((v, index) =&gt; v - val);

  }

  arrayProduct(a1, a2) {

    return a1.map((value, index) =&gt; value * a2[index]);

  }

  vectorCalculation(a) {

    return this.subtractFromEachElement(a, this.getArrayMean(a));

  }

  /**
   * Calculates paddle velocity from past n values in paddle vector of y coordinates
   * @method getPaddleVelocity
   * @param time {int} timestamp in Unixtime of paddle position
   * @param position {Object} {position: {x: number, y: number}, dimensions: {width: number, height: number}}
   * @return {number}  sum((time-mean(time)).*(position-mean(position)))/sum((time-mean(time)).*(time-mean(time)))
   */
  getPaddleVelocity(time, position) {

    let timeVector = this.vectorCalculation(time.slice(time.length - 15, time.length));
    let positionVector = this.vectorCalculation(position.slice(position.length - 15, position.length));

    return this.getArraysum(this.arrayProduct(timeVector, positionVector)) / this.getArraysum(this.arrayProduct(timeVector, timeVector));
  }


  /**
   * Trajectory of the ball after bounce event
   * @method bounceTrajectory
   */
  bounceTrajectory() {
    let Xiterator = super.getElapsedTime(initialTime);
    let Yiterator = super.getElapsedTime(ball.impactTime);

    this.ctx.beginPath();
    let positionY = ball.impactPosition + paddle.releaseVelocity * (Yiterator) + 0.5 * -super.TrajectoryVars.gravity * Math.pow(Yiterator, 2);
    let positionX = super.TrajectoryVars.initX + super.TrajectoryVars.ballvx * (Xiterator);
    let leftBorder = (positionX - 0.0175) * super.Utils.SCALE;
    if(ball.positions.length &gt; 80){
      ball.positions = ball.positions.slice(-80);
    }
    ball.positions.push(ball.position);
    ball.position.x = leftBorder;
    ball.position.y = this.canvas.height - positionY * this.canvas.height ;


  }


  /**
   *
   * Handle paddle collision here
   * Adjust velocity to the ball by restitution factor
   * Release velocity calculation ,  alpha : restitute factor = 0.7
   * ball_velocity  =   initV  -  gravity *  t  , where t is the time since start of the trajectory
   * paddleVelocity  :  calculated from n past  vector values of paddle y coordinates (in pixel values)  and time in
   * seconds
   * @method paddleBallCollision
   */
  paddleBallCollision() {

    //Detect the ball position on X axis , if the ball is between paddle edges
    if (ball.position.x &gt;= (1.256) * super.Utils.SCALE - 0.04 * super.Utils.SCALE &amp;&amp; ball.position.x &lt;= (1.406) * super.Utils.SCALE) {

      //Check if paddle actually moved on Y axis and delta is significant enough
      let paddleDelta = paddle.positions[paddle.positions.length - 1] - paddle.positions[paddle.positions.length - 20];
      if (paddleDelta &lt; 0.1) {
        paddleDelta = 0.1;
      }
      //Detect the ball position on Y axes, if the ball is within range  on Y axis
      if (Math.abs(ball.position.y - paddle.position.y) &lt;= paddleDelta * super.Utils.SCALE &amp;&amp; ball.position.y - paddle.position.y &gt;= 0) {
        let paddleVelocity = this.getPaddleVelocity(paddle.times, paddle.positions);
        sounds[gameSound.BOUNCING].play();
        paddle.paddleLastMovedMillis = new Date().getTime();
        ball.impactTime = new Date().getTime();
        ball.impactPosition = (this.canvas.height - (paddle.position.y - paddle.dimensions.height - paddleDelta)) / this.canvas.height;
        let iterator = super.getElapsedTime(initialTime);
        ball.velocity = super.TrajectoryVars.initV - super.TrajectoryVars.gravity * iterator;
        paddle.releaseVelocity = -alpha * (ball.velocity - paddleVelocity) + paddleVelocity;
        //Fix for abrupt trajectory, make sure the trajectory is not negative
        if (paddle.releaseVelocity &gt; 1.4) {
          paddle.releaseVelocity = 1.4;
        }

        if (isNaN(paddle.releaseVelocity)) {
          paddle.releaseVelocity = 1.56;
        }
        ball.state = &#x27;bounce&#x27;;
        // Update initial position of ball according to trajectory to prevent possible gap
        this.bounceTrajectory();
      }
    }

  }


  /**
   *
   * Check if ball reached the target
   * @method collisionDetection
   * @return {boolean}
   */
  collisionDetection() {


    let YL = (targetLocV - 0.43) * super.Utils.SCALE;
    let YH = (targetLocV + 0.72) * super.Utils.SCALE;
    let XH = targetLocH * super.Utils.SCALE;

    if (ball.state !== &#x27;done&#x27; &amp;&amp; ball.position.y &gt; YL &amp;&amp; ball.position.y &lt; YH &amp;&amp; ball.position.x &gt; XH) {
      let currenImpactCoord = Math.abs(ball.position.y - targetLocV * super.Utils.SCALE);

      if (currenImpactCoord &lt; 0.27 * super.Utils.SCALE) {

        if (currenImpactCoord &lt; 0.03 * super.Utils.SCALE) {

          ball.hitstate = &#x27;very good&#x27;;

        } else {

          ball.hitstate = &#x27;good&#x27;;
        }


      } else {

        ball.hitstate = &#x27;hit&#x27;;

      }


      return true;

    }


    return false;
  }


  /**
   *
   * Initialize each game round with initial object parameters
   * Randomize number of obstructions
   * @method initGame
   */
  initGame() {


    jitterT = super.trialStartTime();
    ball = super.ballObject();
    initialTime = 0;

    token.dimensions = {width: 0.21 * super.Utils.SCALE, height: 0.2 * super.Utils.SCALE};
    //For first trial wait for paddle to start in Box position, make sure the paddle is not moved
    if (super.currentRounds &gt; 0 || (super.currentRounds === 0 &amp;&amp; !super.paddleIsMoved(paddle,true))) {
      sounds[gameSound.START].play();
    }

    super.initGame();

  }

  /**
   *
   * Export data
   * @method dataCollection
   */
  dataCollection() {
    super.dataCollection();
    let exportData = {
      game_type: &#x27;BounceGame&#x27;,
      ball_position_x: ball.position.x / this.canvas.width,
      ball_position_y: (this.canvas.height - ball.position.y) / this.canvas.height,
      paddle_center_x: paddle.position.x + paddle.dimensions.width / 2,
      paddle_width: paddle.dimensions.width,
      paddle_position_y: (this.canvas.height - paddle.position.y) / this.canvas.height,
      trial: super.currentRounds,
      timestamp: new Date().getTime()

    };

    super.storeData(exportData);

  }

}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
